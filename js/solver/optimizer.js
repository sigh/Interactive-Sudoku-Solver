const { memoize, arrayIntersectSize, arrayDifference, setIntersectSize, arrayIntersect, arrayRemoveValue, setIntersectionToArray, setDifference, BitSet, elementarySymmetricSum, mergeSortedArrays } = await import('../util.js' + self.VERSION_PARAM);
const { LookupTables } = await import('./lookup_tables.js' + self.VERSION_PARAM);
const { SudokuConstraintBase, fnToBinaryKey } = await import('../sudoku_constraint.js' + self.VERSION_PARAM);
const HandlerModule = await import('./handlers.js' + self.VERSION_PARAM);
const SumHandlerModule = await import('./sum_handler.js' + self.VERSION_PARAM);
const NFAModule = await import('./nfa_handler.js' + self.VERSION_PARAM);

export class SudokuConstraintOptimizer {
  // Maximum number of cells in some sums generated by the optimizers.
  _MAX_SUM_SIZE = 6;

  constructor(debugLogger) {
    this._debugLogger = null;
    if (debugLogger.enableLogs) {
      this._debugLogger = debugLogger;
    }
    this._forbiddenStackPool = null;
  }

  _logAddHandler(loc, handler, { args = null, cells = null, aux = false } = {}) {
    if (!this._debugLogger) return;

    const auxSuffix = aux ? ' (aux)' : '';

    const entry = {
      loc,
      msg: 'Add: ' + handler.constructor.name + auxSuffix,
    };

    if (args) entry.args = args;
    if (cells) entry.cells = cells;
    else if (handler.cells) entry.cells = handler.cells;

    this._debugLogger.log(entry);
  }

  optimize(handlerSet, cellExclusions, shape) {
    const hasBoxes = (
      handlerSet.getAllofType(HandlerModule.NoBoxes).length === 0
      && !shape.noDefaultBoxes);

    this._addExtraCellExclusions(handlerSet, cellExclusions, shape);

    this._addHouseHandlers(handlerSet, shape);

    if (!shape.isSquare()) {
      this._optimizeNonSquareGrids(handlerSet, hasBoxes, shape);
    }

    this._optimizeSums(handlerSet, cellExclusions, hasBoxes, shape);

    this._optimizeJigsaw(handlerSet, hasBoxes, shape);

    this._optimizeFullRank(handlerSet, shape);

    this._optimizeRequiredValues(handlerSet, cellExclusions, shape);

    this._optimizeTaxicab(handlerSet, cellExclusions, shape);

    this._optimizeBinaryPairwise(handlerSet);

    if (hasBoxes) {
      this._addHouseIntersections(handlerSet, shape);
    }

    this._logStats(handlerSet);
  }

  _optimizeNonSquareGrids(handlerSet, hasBoxes, shape) {
    // For non-square grids without boxes, one axis forms houses
    // and the other axis has numValues lines of length K < numValues.
    // Since those K-length lines are all-different then for each value it must
    // appear in exactly K of those numValues lines.
    // Add an auxiliary handler that propagates this fact.

    // Note: Without this empty grids can be VERY slow. However, when there are
    // some constraints (or possibly just deeper into the solve) this constraint
    // just slows things down.
    // However, rectangular grids without boxes are relatively rare, so it's
    // ok to just ensure that we avoid the worst cases here.

    // We don't need this if there are boxes, as the box constraints provide
    // sufficient propagation.
    if (hasBoxes) return;

    // Determine the axis that has numValues *lines* (the longer dimension).
    // Those lines have length K = min(numRows, numCols).
    let lines;
    let requiredLineCount;
    const numValues = shape.numValues;

    if (shape.numCols === numValues) {
      // Columns: numValues lines, each with numRows cells.
      lines = SudokuConstraintBase.colRegions(shape);
      requiredLineCount = shape.numRows;
    } else if (shape.numRows === numValues) {
      // Rows: numValues lines, each with numCols cells.
      lines = SudokuConstraintBase.rowRegions(shape);
      requiredLineCount = shape.numCols;
    }

    // This optimization assumes that the longer dimension equals numValues.
    // With non-default numValues (e.g. 9x9~10), that assumption doesn't hold,
    // so skip this optimization.
    if (!lines) return;
    // If we only have 1 line, this constraint has no effect.
    // If we have 2 lines, then only there is minimal propagation possible,
    // because its not very constraining.
    if (requiredLineCount <= 2) return;

    // Pack all line cell indices into one backing store and create per-line views.
    const backing = Uint8Array.from(lines.flat());
    const packedLines = lines.map(
      (_, i) => backing.subarray(
        requiredLineCount * i,
        requiredLineCount * (i + 1)));

    const handler = new HandlerModule.FullGridRequiredValues(
      shape.allCells,
      packedLines);
    handlerSet.addAux(handler);
    this._logAddHandler('_addFullGridRequiredValues', handler, {
      aux: true,
      args: { requiredLineCount },
    });
  }

  static _equalsKey = memoize((numValues) => fnToBinaryKey(
    (a, b) => a == b, numValues));

  _addExtraCellExclusions(handlerSet, cellExclusions, shape) {
    // If two cells must have the same value, then they have to share the same
    // cell exclusions.
    // This will allow Palindrome and SameValue constraints to propagate their
    // restrictions better.
    const binaryHandlers = [
      ...handlerSet.getAllofType(
        HandlerModule.BinaryConstraint),
      ...handlerSet.getAllofType(
        HandlerModule.BinaryPairwise)];
    const equalsKey = SudokuConstraintOptimizer._equalsKey(shape.numValues);

    for (const h of binaryHandlers) {
      if (h.key() !== equalsKey) continue;
      for (let i = 1; i < h.cells.length; i++) {
        for (let j = 0; j < i; j++) {
          cellExclusions.areSameValue(h.cells[i], h.cells[j]);
        }
      }
    }
  }

  _addHouseIntersections(handlerSet, shape) {
    const houseHandlers = handlerSet.getAllofType(HandlerModule.House);
    const numHandlers = houseHandlers.length;
    for (let i = 1; i < numHandlers; i++) {
      for (let j = 0; j < i; j++) {
        const intersectionSize = arrayIntersectSize(
          houseHandlers[i].cells, houseHandlers[j].cells);
        if (intersectionSize !== shape.boxWidth && intersectionSize !== shape.boxHeight) continue;
        const newHandler = new HandlerModule.SameValuesIgnoreCount(
          arrayDifference(houseHandlers[i].cells, houseHandlers[j].cells),
          arrayDifference(houseHandlers[j].cells, houseHandlers[i].cells));
        handlerSet.addAux(newHandler);
        this._logAddHandler('_addHouseIntersections', newHandler, { aux: true });
      }
    }
  }

  _optimizeJigsaw(handlerSet, hasBoxes, shape) {
    const jigsawPieces = handlerSet.getAllofType(HandlerModule.JigsawPiece);
    if (jigsawPieces.length === 0) return;

    handlerSet.addNonEssential(
      ...this._makeJigsawIntersections(handlerSet));

    handlerSet.addNonEssential(
      ...this._makeJigsawLawOfLeftoverHandlers(jigsawPieces, hasBoxes, shape));
  }

  // Find a non-overlapping set of handlers.
  _findNonOverlappingSubset(handlers, fullHandlerSet) {
    const handlerIndexes = new Set(
      handlers.map(h => fullHandlerSet.getIndex(h)));

    // Sort handers by number of overlapping handlers.
    const handlersByOverlaps = [];
    for (const h of handlers) {
      const overlapIndexes = fullHandlerSet.getIntersectingIndexes(h);
      const numOverlap = setIntersectSize(overlapIndexes, handlerIndexes);
      handlersByOverlaps.push([h, numOverlap]);
    }
    handlersByOverlaps.sort((a, b) => a[1] - b[1]);

    // Find a set of mutually non-overlapping handlers.
    // Start with the handlers with the least overlaps as they restrict future
    // choices the least.
    // i.e. greedy bin-packing.
    const cellsIncluded = new Set();
    const nonOverlappingHandlers = [];
    for (const [h,] of handlersByOverlaps) {
      if (h.cells.some(c => cellsIncluded.has(c))) continue;
      nonOverlappingHandlers.push(h);
      h.cells.forEach(c => cellsIncluded.add(c));
    }

    return [nonOverlappingHandlers, cellsIncluded];
  }

  _optimizeSums(handlerSet, cellExclusions, hasBoxes, shape) {
    // TODO: Consider how this interacts with fixed cells.
    const allSumHandlers = handlerSet.getAllofType(SumHandlerModule.Sum);
    if (allSumHandlers.length === 0) return;
    // Exclude any handlers with duplicate cells from any of the optimizations.
    // TODO: Check which optimizations are still valid.
    const safeSumHandlers = allSumHandlers.filter(h => h.onlyUnitCoeffs());

    const [filteredSumHandlers, sumCells] =
      this._findNonOverlappingSubset(safeSumHandlers, handlerSet);

    handlerSet.addNonEssential(
      ...this._fillInSumGap(filteredSumHandlers, sumCells, shape));

    handlerSet.addNonEssential(
      ...this._makeInnieOutieSumHandlers(filteredSumHandlers, hasBoxes, shape));

    handlerSet.addNonEssential(
      ...this._makeHiddenCageHandlers(handlerSet, safeSumHandlers, cellExclusions, shape));

    handlerSet.addNonEssential(
      ...this._makeCombinedSumHandlers(safeSumHandlers, cellExclusions, shape));

    this._replaceSizeSpecificSumHandlers(handlerSet, cellExclusions, shape);

    // Don't pass in the sum handlers so that this phase can operate on all the
    // new sum handlers that were added.
    this._addSumComplementCells(handlerSet);

    return;
  }

  _makeCombinedSumHandlers(allSumHandlers, cellExclusions, shape) {
    // Bounded, greedy merge process:
    // - Assign a score to each record
    // - Only merge two records if the merged score is strictly better than BOTH inputs.
    // - Once merged, the two inputs are removed and only the merged record remains.
    // This prevents exponential blowup.

    const scoreOf = (groups, dof) => {
      let score = 0;
      for (const g of groups) {
        const k = g.length;
        // How much "slack" this group provides beyond the dof.
        score += k * (shape.numValues - k) - dof;
      }
      return score;
    };

    const keyFromSortedCells = (cells) => cells.join(',');

    const recordFromCellsAndSum = (cells, sum, original, key) => {
      const groups = HandlerModule.HandlerUtil.findExclusionGroupsGreedy(
        cells, cellExclusions).groups;
      const { range, min, max } = HandlerModule.HandlerUtil.exclusionGroupSumInfo(
        groups, shape.numValues);
      if (sum < min || sum > max) return null;

      const dof = Math.min(sum - min, max - sum);
      const cellsBitSet = new BitSet(shape.numCells);
      for (const c of cells) cellsBitSet.add(c);

      return {
        key: key || keyFromSortedCells(cells),
        cells, cellsBitSet,
        sum, range, dof,
        score: scoreOf(groups, dof),
        original,
      };
    };

    const areRelatedNonOverlapping = (r1, r2) => {
      // Disallow overlap.
      if (r1.cellsBitSet.hasIntersection(r2.cellsBitSet)) return false;

      // Related iff there exists at least 6 cells with exclusion edges between
      // the sets.
      const MIN_OVERLAP_COUNT = 6;
      const [small, big] = r2.cells.length < r1.cells.length
        ? [r2, r1] : [r1, r2];
      if (small.cells.length < MIN_OVERLAP_COUNT) return false;
      let count = 0;
      for (const cell of small.cells) {
        if (cellExclusions.getBitSet(cell).hasIntersection(big.cellsBitSet)) {
          if (++count >= MIN_OVERLAP_COUNT) return true;
        }
      }
      return false;
    };

    const isBetterCandidate = (a, b) => {
      if (a.score !== b.score) return a.score > b.score;
      // Deterministic tie-breaker: prefer lexicographically-larger key.
      return a.key > b.key;
    };

    // Active pool keyed by sorted cell list.
    const activeByKey = new Map();

    const candidates = [];
    const pushCandidate = (r1, r2) => {
      if (!areRelatedNonOverlapping(r1, r2)) return;

      const combinedCells = mergeSortedArrays(r1.cells, r2.cells);
      const combinedKey = keyFromSortedCells(combinedCells);
      if (activeByKey.has(combinedKey)) return;

      const combinedSum = r1.sum + r2.sum;
      const combinedRecord = recordFromCellsAndSum(
        combinedCells, combinedSum, false, combinedKey);
      if (!combinedRecord) return;

      // Accept if strictly better than both inputs, or better than their sum.
      if (combinedRecord.score <= r1.score || combinedRecord.score <= r2.score) {
        if (combinedRecord.score <= r1.score + r2.score) return;
      }

      candidates.push({
        score: combinedRecord.score,
        key: combinedKey,
        r1,
        r2,
        combined: combinedRecord,
      });
    };

    for (const h of allSumHandlers) {
      const cells = [...h.cells];
      cells.sort((a, b) => a - b);

      const r = recordFromCellsAndSum(cells, h.sum(), true);
      if (!r) continue;

      // Prefer first occurrence if duplicates exist.
      if (activeByKey.has(r.key)) continue;
      activeByKey.set(r.key, r);
    }

    // Initial candidate generation.
    const initialRecords = [...activeByKey.values()];
    for (let i = 0; i < initialRecords.length; i++) {
      for (let j = i + 1; j < initialRecords.length; j++) {
        pushCandidate(initialRecords[i], initialRecords[j]);
      }
    }

    // Apply merges in descending score order.
    while (true) {
      let bestIdx = -1;
      let bestCand = null;
      for (let i = 0; i < candidates.length; i++) {
        const cand = candidates[i];

        // Skip invalidated candidates (parents removed or combined already exists).
        if (activeByKey.get(cand.r1.key) !== cand.r1
          || activeByKey.get(cand.r2.key) !== cand.r2
          || activeByKey.has(cand.combined.key)) {
          // Swap-remove invalid candidate.
          candidates[i] = candidates[candidates.length - 1];
          candidates.pop();
          if (bestIdx === candidates.length) bestIdx = i;
          i--;
          continue;
        }

        if (!bestCand || isBetterCandidate(cand, bestCand)) {
          bestCand = cand;
          bestIdx = i;
        }
      }
      if (!bestCand) break;

      // Swap-remove chosen candidate.
      candidates[bestIdx] = candidates[candidates.length - 1];
      candidates.pop();

      const best = bestCand.combined;
      activeByKey.delete(bestCand.r1.key);
      activeByKey.delete(bestCand.r2.key);
      activeByKey.set(best.key, best);

      // Only new pairs involving the merged record can become valid.
      for (const other of activeByKey.values()) {
        if (other === best) continue;
        pushCandidate(best, other);
      }
    }

    // Instantiate handlers only for inferred sums with sufficient score.
    const newHandlers = [];
    for (const r of activeByKey.values()) {
      if (r.original || r.score <= 0) continue;
      newHandlers.push(new SumHandlerModule.Sum(r.cells, r.sum));
      this._debugLogger?.log({
        loc: '_makeCombinedSumHandlers',
        msg: 'Add: ' + SumHandlerModule.Sum.name,
        args: { sum: r.sum, range: r.range, dof: r.dof, score: r.score },
        cells: r.cells,
      });
    }

    return newHandlers;
  }

  _findCommonHandlers(cells, handlerSet, houseHandlerIndexes) {
    const cellMap = handlerSet.getOrdinaryHandlerMap();

    let commonHandlers = houseHandlerIndexes;
    for (const c of cells) {
      commonHandlers = arrayIntersect(commonHandlers, cellMap[c]);
      if (commonHandlers.length === 0) return commonHandlers;
    }

    return commonHandlers;
  }

  _addSumComplementCells(handlerSet) {
    const houseHandlers = (
      handlerSet.getAllofType(HandlerModule.House).map(
        h => handlerSet.getIndex(h)));

    for (const h of handlerSet.getAllofType(SumHandlerModule.Sum)) {
      if (!h.onlyUnitCoeffs()) continue;

      const cells = h.cells;
      const commonHandlers = this._findCommonHandlers(
        cells, handlerSet, houseHandlers);
      if (commonHandlers.length === 0) continue;
      const commonHandler = handlerSet.getHandler(commonHandlers[0]);

      const complementCells = arrayDifference(commonHandler.cells, cells);
      h.setComplementCells(complementCells);
    }
  }

  _fillInSumGap(sumHandlers, sumCells, shape) {
    // Fill in a gap if one remains.
    const numNonSumCells = shape.numCells - sumCells.size;
    if (numNonSumCells == 0 || numNonSumCells >= shape.numValues) return [];

    const sumHandlersSum = sumHandlers.map(h => h.sum()).reduce((a, b) => a + b);
    const numRegions = shape.numCells / shape.numValues;
    const remainingSum = numRegions * shape.maxSum - sumHandlersSum;

    const remainingCells = new Set(shape.allCells);
    sumHandlers.forEach(h => h.cells.forEach(c => remainingCells.delete(c)));
    const newHandler = new SumHandlerModule.Sum(
      [...remainingCells], remainingSum);

    sumHandlers.push(newHandler);
    remainingCells.forEach(c => sumCells.add(c));

    if (this._debugLogger) {
      this._logAddHandler('_fillInSumGap', newHandler, {
        args: { sum: remainingSum },
      });
    }

    return [newHandler];
  }

  // Add house handlers for any AllDifferentHandler which have numValues cells.
  _addHouseHandlers(handlerSet, shape) {
    for (const h of
      handlerSet.getAllofType(HandlerModule.AllDifferent)) {
      const cells = h.exclusionCells();
      if (cells.length === shape.numValues) {
        handlerSet.addNonEssential(
          new HandlerModule.House(cells));
      }
    }
  }

  // Find {1-2}-cell sum constraints and replace them dedicated handlers.
  _replaceSizeSpecificSumHandlers(handlerSet, cellExclusions, shape) {
    const sumHandlers = handlerSet.getAllofType(SumHandlerModule.Sum);
    for (const h of sumHandlers) {
      let newHandler;
      switch (h.cells.length) {
        case 1:
          {
            const sum = h.sum();
            const coeff = h.coefficients()[0];
            if (sum % coeff) {
              newHandler = new HandlerModule.False(h.cells);
            } else {
              newHandler = new HandlerModule.GivenCandidates(
                new Map([[h.cells[0], sum / coeff]]));
            }
          }
          break;

        case 2:
          {
            const cells = h.cells;
            const mutuallyExclusive = (
              cellExclusions.isMutuallyExclusive(...cells));
            const sum = h.sum();
            const [c0, c1] = h.coefficients();

            newHandler = new HandlerModule.BinaryConstraint(
              ...cells,
              fnToBinaryKey(
                (a, b) => a * c0 + b * c1 == sum && (!mutuallyExclusive || a != b),
                shape.numValues));
          }
          break;
      }

      if (newHandler) {
        handlerSet.replace(h, newHandler);
        if (this._debugLogger) {
          this._debugLogger.log({
            loc: '_replaceSizeSpecificSumHandlers',
            msg: 'Replace with: ' + newHandler.constructor.name,
            cells: newHandler.cells,
          });
        }
      }
    }
  }

  // Create a Sum handler out of all the cages sticking out of a house.
  _addSumIntersectionHandler(
    houseHandler, intersectingSumHandlers, intersectingHouseHandlers,
    allHouseHandlers, cellExclusions, shape) {
    const numValues = shape.numValues;

    let totalSum = 0;
    let cells = new Set();
    let uncoveredCells = new Set(houseHandler.cells);
    for (const h of intersectingSumHandlers) {
      totalSum += h.sum();
      h.cells.forEach(c => cells.add(c));
      h.cells.forEach(c => uncoveredCells.delete(c));
    }

    // If we haven't filled up the entire house then try to greedily fill the
    // holes with house handlers.
    let usedExtraHouses = false;
    if (uncoveredCells.size > 0) {
      for (const h of intersectingHouseHandlers) {
        // Ignore any houses which intersect with the existing cells.
        if (setIntersectSize(cells, h.cells) > 0) continue;
        // Ignore any houses which don't cover the uncovered cells.
        const intersectSize = setIntersectSize(uncoveredCells, h.cells);
        if (intersectSize == 0) continue;
        // Ignore handlers which only intersect in one square. This is likely
        // a row crossing a column, and is generally not useful.
        if (intersectSize == 1) continue;
        // Ensure the intersection only covers the uncovered cells.
        if (intersectSize != arrayIntersectSize(houseHandler.cells, h.cells)) {
          continue;
        }
        // This handler fills in an existing gap.
        totalSum += shape.maxSum;
        h.cells.forEach(c => cells.add(c));
        h.cells.forEach(c => uncoveredCells.delete(c));
        usedExtraHouses = true;
        if (uncoveredCells.size == 0) break;
      }
    }

    // If we still haven't covered all the cells, then give up.
    if (uncoveredCells.size > 0) return null;

    // Remove the current house cells, as we care about the cells outside the
    // house.
    houseHandler.cells.forEach(c => cells.delete(c));
    totalSum -= shape.maxSum;

    // While it's possible that there could be a house completely contained
    // within the cells, then try to find and remove them.
    // Note that houses used to construct the cells won't match as we have
    // already removed the cells in the current house.
    let removedExtraHouses = false;
    if (cells.size >= numValues) {
      for (const h of allHouseHandlers) {
        // Ignore any houses which don't cover the cells.
        const intersectSize = setIntersectSize(cells, h.cells);
        if (intersectSize != numValues) continue;
        // This house is completely contained within the cells.
        totalSum -= shape.maxSum;
        h.cells.forEach(c => cells.delete(c));
        removedExtraHouses = true;
        if (cells.size < numValues) break;
      }
    }

    if (cells.size == 0) return null;

    // Use mutual-exclusion structure to estimate how restrictive this inferred
    // sum will be. Prefer sums that imply a narrow range relative to dof.
    const cellsArray = [...cells];
    // Sort so that the result is deterministic, and also makes greedy grouping
    // naturally align on rows.
    cellsArray.sort((a, b) => a - b);
    const groups = HandlerModule.HandlerUtil.findExclusionGroupsGreedy(
      cellsArray, cellExclusions).groups;
    const { range, min, max } = HandlerModule.HandlerUtil.exclusionGroupSumInfo(
      groups, shape.numValues);
    if (totalSum < min || totalSum > max) {
      // Infeasible sum, fail the puzzle.
      const handler = new HandlerModule.False(cellsArray);
      this._logAddHandler(
        '_addSumIntersectionHandler', handler, { totalSum, min, max });
      return handler;
    }

    const dof = Math.min(totalSum - min, max - totalSum);
    if (range == 0 || range <= 4 * dof) {
      if (this._debugLogger) {
        this._debugLogger.log({
          loc: '_addSumIntersectionHandler',
          msg: 'Skip',
          args: { sum: totalSum, range: range },
          cells: cellsArray,
        });
      }
      return null;
    }

    const handler = new SumHandlerModule.Sum(cellsArray, totalSum);

    if (this._debugLogger) {
      let args = {
        sum: handler.sum(), size: handler.cells.length,
        minSum: min, maxSum: max, range
      };
      if (usedExtraHouses) args.usedExtraHouses = usedExtraHouses;
      if (removedExtraHouses) args.removedExtraHouses = removedExtraHouses;
      this._logAddHandler('_addSumIntersectionHandler', handler, { args });
    }

    return handler;
  }

  // Find sets of cells which we can infer have a known sum and unique values.
  _makeHiddenCageHandlers(handlerSet, allSumHandlers, cellExclusions, shape) {
    const houseHandlers = handlerSet.getAllofType(HandlerModule.House);
    const newHandlers = [];

    const allSumHandlerIndexes = new Set(
      allSumHandlers.map(h => handlerSet.getIndex(h)));
    const houseHandlerIndexes = new Set(
      houseHandlers.map(h => handlerSet.getIndex(h)));

    for (const h of houseHandlers) {
      // Find sum constraints which overlap this house.
      let intersectingHandlers = handlerSet.getIntersectingIndexes(h);
      const currentHouseSumIndexes = setIntersectionToArray(
        intersectingHandlers, allSumHandlerIndexes);
      if (currentHouseSumIndexes.length === 0) continue;

      // For the sum intersection, we need to ensure that the sum handlers don't
      // overlap themselves.
      // We do this separately for each house so that we can don't have to
      // force the same handle to be used in every house it intersects.
      const [filteredSumHandlers] = this._findNonOverlappingSubset(
        currentHouseSumIndexes.map(i => handlerSet.getHandler(i)),
        handlerSet);

      {
        const intersectingHouseHandlers = (
          setIntersectionToArray(intersectingHandlers, houseHandlerIndexes)).map(
            i => handlerSet.getHandler(i));
        const sumIntersectionHandler = this._addSumIntersectionHandler(
          h, filteredSumHandlers, intersectingHouseHandlers, houseHandlers,
          cellExclusions, shape);
        if (sumIntersectionHandler) newHandlers.push(sumIntersectionHandler);
      }

      // Outies are cages which stick out of the house by 1 cell.
      const outies = [];
      // Constrained cells are those from cages which are fully contained within
      // the house.
      const constrainedCells = [];
      let constrainedSum = 0;
      for (const k of filteredSumHandlers) {
        const overlapSize = arrayIntersectSize(h.cells, k.cells);
        if (overlapSize == k.cells.length) {
          constrainedCells.push(...k.cells);
          constrainedSum += k.sum();
          k.setComplementCells(arrayDifference(h.cells, k.cells));
        } else if (k.cells.length - overlapSize == 1) {
          outies.push(k);
        }
      }

      // Short-circuit the common case where there is nothing special in the
      // house.
      if (outies.length === 0 && constrainedCells.length === 0) continue;

      const complementCells = arrayDifference(h.cells, constrainedCells);
      const complementSum = shape.maxSum - constrainedSum;

      // If a cage sticks out of a house by 1 cell, then we can form the
      // equivalent of an arrow sum (with offset). That is, the value of the
      // cell outside house is direct offset of the sum of the remaining
      // cells in the house outside the cage. The sum can be further reduced
      // by any other cages (i.e. known sums) in the house.
      for (const o of outies) {
        const remainingCells = arrayDifference(complementCells, o.cells);
        // Don't add sums with too many cells.
        if (remainingCells.length + 1 > this._MAX_SUM_SIZE) continue;

        const extraCells = arrayDifference(o.cells, h.cells);
        const remainingSum = complementSum - o.sum();
        const handlerCells = [...remainingCells, ...extraCells];
        const coeffs = handlerCells.map(
          (_, i) => i < remainingCells.length ? 1 : -1);
        const handler = new SumHandlerModule.Sum(
          handlerCells, remainingSum, coeffs);
        newHandlers.push(handler);

        if (this._debugLogger) {
          this._logAddHandler('_makeHiddenCageHandlers', handler, {
            args: { offset: remainingSum, negativeCells: [...extraCells] },
          });
        }
      }

      // No constraints within this house.
      if (constrainedCells.length === 0) continue;
      // The remaining 8-cell will already be constrained after the first
      // pass.
      if (constrainedCells.length === 1) continue;
      // Nothing left to constrain.
      if (constrainedCells.length === shape.numValues) continue;

      const complementHandler = new SumHandlerModule.Sum(
        complementCells, complementSum);
      complementHandler.setComplementCells(constrainedCells);
      newHandlers.push(complementHandler);
      if (this._debugLogger) {
        this._logAddHandler('_makeHiddenCageHandlers', complementHandler, {
          args: { sum: complementSum },
        });
      }
    }

    return newHandlers;
  }

  // Add same value handlers for the intersections between houses.
  _makeJigsawIntersections(handlerSet) {
    const houseHandlers = handlerSet.getAllofType(HandlerModule.House);
    const newHandlers = [];

    // Add constraints due to overlapping regions.
    for (const h0 of houseHandlers) {
      for (const h1 of houseHandlers) {
        if (h0 === h1) continue;

        const diff0 = arrayDifference(h0.cells, h1.cells);
        if (
          // Skip empty diffs.
          diff0.length === 0
          // Also diffs that are too large.
          || diff0.length > this._MAX_SUM_SIZE
          // Ensure overlap is more than one cell.
          || diff0.length === h0.cells.length - 1) continue;

        // We have some overlapping cells!
        // This means diff0 and diff1 must contain the same values.
        const diff1 = arrayDifference(h1.cells, h0.cells);

        // TODO: Optimize the diff0.length === 1 case (and 2?).
        const handler = new HandlerModule.SameValuesIgnoreCount(diff0, diff1);
        newHandlers.push(handler);
        this._logAddHandler('_makeJigsawIntersections', handler);
      }
    }

    return newHandlers;
  }

  // Returns region-groups used by the jigsaw overlap optimizations.
  // Key detail: whether an axis forms houses depends on (numRows/numCols === numValues),
  // so we memoize based on those booleans + grid dimensions (not on shape identity).
  _overlapRegions = memoize(
    (shape, hasBoxes) => {
      const regions = [];

      // Rows are houses if they have numValues cells (numCols === numValues).
      if (shape.numCols === shape.numValues) {
        const rowRegions = SudokuConstraintBase.rowRegions(shape);
        regions.push(rowRegions, rowRegions.slice().reverse());
      }

      // Columns are houses if they have numValues cells (numRows === numValues).
      if (shape.numRows === shape.numValues) {
        const colRegions = SudokuConstraintBase.colRegions(shape);
        regions.push(colRegions, colRegions.slice().reverse());
      }

      if (hasBoxes) {
        regions.push(SudokuConstraintBase.boxRegions(shape));
      }

      return regions;
    },
    (shape, hasBoxes) => {
      const rowHouses = shape.numCols === shape.numValues;
      const colHouses = shape.numRows === shape.numValues;
      return `${shape.gridDimsStr}|${rowHouses}|${colHouses}|${!!hasBoxes}`;
    });

  _generalRegionOverlapProcessor(regions, pieces, numValues, callback) {
    const superRegion = new Set();
    const remainingPieces = new Set(pieces);
    const usedPieces = [];
    const piecesRegion = new Set();

    let i = 0;
    for (const r of regions) {
      i++;
      if (i == numValues) break;

      // Add r to our super-region.
      r.forEach(e => superRegion.add(e));

      // Add any remaining pieces with enough overlap to our super-region.
      for (const p of remainingPieces) {
        const intersectionSize = setIntersectSize(superRegion, p);
        if (intersectionSize > p.length / 2) {
          remainingPieces.delete(p);
          for (const c of p) piecesRegion.add(c);
          usedPieces.push(p);
        }
      }

      // Don't process the first region, as that usually doubles up work from
      // elsewhere.
      if (i == 1) continue;

      callback(superRegion, piecesRegion, usedPieces);
    }
  }

  _makeJigsawLawOfLeftoverHandlers(jigsawPieces, hasBoxes, shape) {
    const newHandlers = [];

    const handleOverlap = (superRegion, piecesRegion, usedPieces) => {
      // We can only match when regions are the same size.
      if (superRegion.size != piecesRegion.size) return;

      const diffA = setDifference(superRegion, piecesRegion);
      if (diffA.size == 0) return;
      const diffB = setDifference(piecesRegion, superRegion);
      // Ignore diff that too big, they are probably not very well
      // constrained.
      if (diffA.size >= shape.numValues) return;

      // All values in the set differences must be the same.
      const newHandler = new HandlerModule.SameValuesIgnoreCount(diffA, diffB);
      newHandlers.push(newHandler);
      this._logAddHandler('_makeJigsawLawOfLeftoverHandlers', newHandler);
    }

    const overlapRegions = this._overlapRegions(shape, hasBoxes);
    for (const r of overlapRegions) {
      this._generalRegionOverlapProcessor(
        r, jigsawPieces.map(p => p.cells), shape.numValues, handleOverlap);
    }

    return newHandlers;
  }

  _makeInnieOutieSumHandlers(sumHandlers, hasBoxes, shape) {
    const newHandlers = [];
    const numValues = shape.numValues;

    const pieces = sumHandlers.map(h => h.cells);
    const piecesMap = new Map(sumHandlers.map(h => [h.cells, h.sum()]));

    const cellsInSum = new Set();
    sumHandlers.forEach(h => h.cells.forEach(c => cellsInSum.add(c)));
    const hasCellsWithoutSum = (cells) => {
      for (const c of cells) {
        if (!cellsInSum.has(c)) return true;
      }
      return false;
    };

    const handleOverlap = (superRegion, piecesRegion, usedPieces) => {
      let diffA = setDifference(superRegion, piecesRegion);
      let diffB = setDifference(piecesRegion, superRegion);

      // No diff, no new constraints to add.
      if (diffA.size == 0 && diffB.size == 0) return;
      // Don't use this if the diff is too large.
      if (diffA.size + diffB.size > numValues) return;

      // We can only do negative sum constraints when the diff is 1.
      // We can only do sum constraints when the diff is 0.
      if (diffA.size > 2 && diffB.size > 2) return;

      if (!(hasCellsWithoutSum(diffA) || hasCellsWithoutSum(diffB))) {
        // If all cells in the diff overlap with a piece, then limit the size of
        // the sum.
        if (diffA.size + diffB.size > this._MAX_SUM_SIZE) return;
        // Otherwise we are adding a sum constraint to a cell which doesn't
        // currently have one, so we'll take all the help we can get!
      }

      let sumDelta = -superRegion.size * shape.maxSum / numValues;
      for (const p of usedPieces) sumDelta += piecesMap.get(p);

      // Ensure diffA is the smaller.
      if (diffA.size > diffB.size) {
        [diffA, diffB] = [diffB, diffA];
        sumDelta = -sumDelta;
      }

      let newHandler;
      let args;
      if (diffA.size == 0) {
        newHandler = new SumHandlerModule.Sum([...diffB], sumDelta);
        args = { sum: sumDelta };
      } else {
        const newHandlerCells = [...diffB, ...diffA];
        const coeffs = newHandlerCells.map((_, i) => i < diffB.size ? 1 : -1);
        newHandler = new SumHandlerModule.Sum(
          newHandlerCells, sumDelta, coeffs);
        args = { sum: sumDelta, negativeCells: [...diffA] };
      }

      newHandlers.push(newHandler);
      this._logAddHandler('_makeInnieOutieSumHandlers', newHandler, { args });
    };

    const overlapRegions = this._overlapRegions(shape, hasBoxes);
    for (const r of overlapRegions) {
      this._generalRegionOverlapProcessor(
        r, pieces, shape.numValues, handleOverlap);
    }

    return newHandlers;
  }

  _optimizeFullRank(handlerSet, shape) {
    const rankHandlers = handlerSet.getAllofType(HandlerModule.FullRank);
    if (rankHandlers.length === 0) return;

    const clues = [];
    let tieMode = HandlerModule.FullRank.TIE_MODE.ANY;
    for (const h of rankHandlers) {
      clues.push(...h.clues());
      tieMode = Math.min(tieMode, h.tieMode());
      handlerSet.replace(h, new HandlerModule.True());
    }

    // Reuse FullRank's entry construction so we stay in sync.
    const entries = HandlerModule.FullRank.buildEntries(shape);
    const equalsKey = SudokuConstraintOptimizer._equalsKey(shape.numValues);

    // Dedupe. Keep the first clue per rank; if we see a duplicate rank,
    // enforce entry equality against the representative.
    const dedupedClues = [];
    const seenRank = new Set();
    for (const clue of clues) {
      if (!seenRank.has(clue.rank)) {
        seenRank.add(clue.rank);
        dedupedClues.push(clue);
        continue;
      }

      // This is a duplicate rank clue, look for the duplicates and stop when
      // we find it (it is guaranteed to be there).
      for (const existingClue of dedupedClues) {
        if (clue.rank !== existingClue.rank) continue;

        const aEntry = HandlerModule.FullRank.entryFromClue(entries, clue);
        const bEntry = HandlerModule.FullRank.entryFromClue(entries, existingClue);
        if (!aEntry || !bEntry) break;

        // TODO: These don't benefit for sharing the same exclusion sets,
        // which is optimized in _addExtraCellExclusions.
        for (let j = 0; j < aEntry.length; j++) {
          const a = aEntry[j];
          const b = bEntry[j];
          if (a === b) continue;
          const eq = new HandlerModule.BinaryConstraint(a, b, equalsKey);
          handlerSet.add(eq);
          this._logAddHandler('_optimizeFullRank', eq, {
            args: { rank: clue.rank },
          });
        }
        break;
      }
    }

    const handler = new HandlerModule.FullRank(
      shape.numCells, dedupedClues, tieMode);
    handlerSet.add(handler);

    if (this._debugLogger) {
      this._debugLogger.log({
        loc: '_optimizeFullRank',
        msg: 'Combine: ' + handler.constructor.name,
        args: {
          numHandlers: rankHandlers.length,
          numClues: clues.length,
          numDedupedClues: dedupedClues.length,
          tieMode,
        },
        cells: handler.cells
      });
    }
  }

  _getForbiddenStack(numWords, count) {
    if (!this._forbiddenStackPool ||
      this._forbiddenStackPool.numWords !== numWords ||
      this._forbiddenStackPool.count < count) {
      this._forbiddenStackPool = BitSet.allocatePool(numWords * 32, count);
      this._forbiddenStackPool.numWords = numWords;
      this._forbiddenStackPool.count = count;
    }
    return this._forbiddenStackPool.bitsets;
  }

  // Find values which must or must not be in certain cells.
  // Returns false if there are no possible combinations, true otherwise.
  _findKnownRequiredValues(cells, value, count, cellExclusions, restrictions, exclusionGroups) {
    const numCells = cells.length;
    if (count > exclusionGroups.length) return false;

    // Estimate complexity to avoid running too long.
    const groupSizes = exclusionGroups.map(g => g.length);
    const MAX_NODES = 120;
    if (elementarySymmetricSum(groupSizes, count) > MAX_NODES) return true;

    const occurrences = new Int16Array(numCells);
    let numCombinations = 0;

    const numGroups = exclusionGroups.length;
    const stack = new Int16Array(numGroups);

    // Values in stack are initialized to -2.
    // The first increment results in -1 (SKIP).
    // If skipping is not allowed, we increment again to 0 (first item).
    const STATE_INITIAL = -2;
    const STATE_SKIP = -1;

    if (numGroups > 0) stack[0] = STATE_INITIAL;
    let stackDepth = 0;

    const pickedCounts = new Int16Array(numGroups + 1);

    // Use BitSets for O(1) checks.
    const numWords = cellExclusions.getBitSet(cells[0]).words.length;
    const forbiddenStack = this._getForbiddenStack(numWords, numGroups + 1);
    forbiddenStack[0].clear();

    while (stackDepth >= 0) {
      const groupIndex = stackDepth;
      const group = exclusionGroups[groupIndex];

      let choice = stack[stackDepth];
      choice++;

      if (choice === STATE_SKIP) {
        const remainingGroups = numGroups - 1 - stackDepth;
        if (pickedCounts[stackDepth] + remainingGroups < count) {
          choice++;
        }
      }

      if (choice >= 0) {
        const forbidden = forbiddenStack[stackDepth];
        while (choice < group.length) {
          if (!forbidden.has(cells[group[choice]])) break;
          choice++;
        }
      }

      if (choice >= group.length) {
        stackDepth--;
        continue;
      }

      stack[stackDepth] = choice;

      let nextPickedCount = pickedCounts[stackDepth];
      if (choice >= 0) nextPickedCount++;

      if (nextPickedCount === count) {
        numCombinations++;
        for (let i = 0; i <= stackDepth; i++) {
          const c = stack[i];
          if (c >= 0) {
            occurrences[exclusionGroups[i][c]]++;
          }
        }
      } else {
        const nextDepth = stackDepth + 1;
        if (nextDepth < numGroups) {
          pickedCounts[nextDepth] = nextPickedCount;
          const nextForbidden = forbiddenStack[nextDepth];
          nextForbidden.copyFrom(forbiddenStack[stackDepth]);
          if (choice >= 0) {
            nextForbidden.union(cellExclusions.getBitSet(cells[group[choice]]));
          }

          stack[nextDepth] = STATE_INITIAL;
          stackDepth++;
        }
      }
    }

    if (numCombinations == 0) return false;

    const addRestriction = (cell, values) => {
      restrictions.set(cell, (restrictions.get(cell) || -1) & values);
    }

    const v = LookupTables.fromValue(value);
    for (let i = 0; i < numCells; i++) {
      if (occurrences[i] === numCombinations) {
        addRestriction(cells[i], v);
      } else if (occurrences[i] == 0) {
        addRestriction(cells[i], ~v);
      }
    }

    return true;
  }

  _optimizeRequiredValues(handlerSet, cellExclusions, shape) {
    const requiredValueHandlers = handlerSet.getAllofType(HandlerModule.RequiredValues);
    if (requiredValueHandlers.length === 0) return;

    const allValues = LookupTables.get(shape.numValues).allValues;

    for (const h of requiredValueHandlers) {
      const restrictions = new Map();
      const exclusionGroups = HandlerModule.HandlerUtil.findMappedExclusionGroups(
        h.cells, cellExclusions).groups;
      // Sort groups by size to optimize search order.
      // Smallest first makes it more likely we can skip larger groups.
      exclusionGroups.sort((a, b) => a.length - b.length);

      // Brute force search for values which are restricted to certain cells.
      for (const [value, count] of h.valueCounts().entries()) {
        if (count > 1) {
          if (!this._findKnownRequiredValues(
            h.cells, value, count, cellExclusions, restrictions, exclusionGroups)) {
            // There were NO combinations found, so this handler is invalid.
            const newHandler = new HandlerModule.False(h.cells);
            handlerSet.replace(h, newHandler);
            if (this._debugLogger) {
              this._debugLogger.log({
                loc: '_optimizeRequiredValues',
                msg: 'Replace with: ' + newHandler.constructor.name,
                cells: newHandler.cells,
              });
            }
          }
        }
      }

      // If there are restrictions, then apply then.
      if (restrictions.size > 0) {
        const newValues = [...h.values()];
        const newCells = [...h.cells];
        const valueMask = LookupTables.fromValuesArray(h.values());

        // Update restrictions and values.
        for (const [cell, v] of restrictions) {
          const values = LookupTables.toValuesArray(v & allValues);
          restrictions.set(cell, values);
          if (values.length === 1) {
            arrayRemoveValue(newValues, values[0]);
            arrayRemoveValue(newCells, cell);
          }
          if (!(v & valueMask)) {
            arrayRemoveValue(newCells, cell);
          }
        }

        // Create a handler to restrict the values.
        const newHandler = new HandlerModule.GivenCandidates(
          restrictions);
        handlerSet.add(newHandler);
        if (this._debugLogger) {
          this._logAddHandler('_optimizeRequiredValues', newHandler, {
            args: { restrictions: Object.fromEntries(restrictions.entries()) },
            cells: h.cells,
          });
        }

        // Replace the old handler if we can remove some cells.
        if (newValues.length === 0) {
          handlerSet.delete(h);
          if (this._debugLogger) {
            this._debugLogger.log({
              loc: '_optimizeRequiredValues',
              msg: 'Delete (no more values): ' + newHandler.constructor.name,
              cells: h.cells,
            });
          }
        } else if (newCells.length !== h.cells.length) {
          const newHandler = new HandlerModule.RequiredValues(
            newCells, newValues);
          handlerSet.replace(h, newHandler);
          if (this._debugLogger) {
            this._debugLogger.log({
              loc: '_optimizeRequiredValues',
              msg: 'Replace with: ' + newHandler.constructor.name,
              args: { newValues },
              cells: newHandler.cells,
            });
          }
        }
      }
    }
  }

  _optimizeTaxicab(handlerSet, cellExclusions, shape) {
    const taxicabHandlers = handlerSet.getAllofType(
      HandlerModule.ValueDependentUniqueValueExclusion);
    if (taxicabHandlers.length === 0) return;

    const valueCellExclusions = [];
    for (let i = 1; i <= shape.numValues; i++) {
      const valueCellExclusion = cellExclusions.clone();
      valueCellExclusions.push(valueCellExclusion);
      for (const h of taxicabHandlers) {
        const cell = h.cells[0];
        for (const otherCell of h.getValueCellExclusions(i)) {
          valueCellExclusion.addMutualExclusion(cell, otherCell);
        }
      }
    }

    const houseHandlers = handlerSet.getAllofType(HandlerModule.House);
    for (const h of houseHandlers) {
      const newHandler = new HandlerModule.ValueDependentUniqueValueExclusionHouse(
        h.cells, valueCellExclusions);
      handlerSet.add(newHandler);
      this._logAddHandler('_optimizeTaxicab', newHandler);
    }
  }

  // Replace 2-cell BinaryPairwise handlers with a direct BinaryConstraint
  // handler. This has less overhead both during runtime and initialization.
  _optimizeBinaryPairwise(handlerSet) {
    const handlers = handlerSet.getAllofType(HandlerModule.BinaryPairwise);
    for (const h of handlers) {
      if (h.cells.length !== 2) continue;
      const newHandler = new HandlerModule.BinaryConstraint(
        ...h.cells, h.key());
      handlerSet.replace(h, newHandler);
      if (this._debugLogger) {
        this._debugLogger.log({
          loc: '_optimizeBinaryPairwise',
          msg: 'Replace with: ' + newHandler.constructor.name,
          cells: newHandler.cells,
        });
      }
    }
  }

  _logStats(handlerSet) {
    if (!this._debugLogger) return;

    const mask = (1 << 16) - 1;

    for (const h of handlerSet.getAllofType(NFAModule.NFAConstraint)) {
      const cnfa = h.getNFA();
      let numTransitionEntries = 0;
      let isDFA = true;
      for (const transitions of cnfa.transitionLists) {
        numTransitionEntries += transitions.length;
        let seen = 0;
        for (const t of transitions) {
          if (t & mask & seen) isDFA = false;
          seen |= t & mask;
        }
      }
      const stateType = isDFA ? ' (DFA)' : '';
      this._debugLogger.log({
        loc: '_logStats',
        msg: `NFAConstraint with ${cnfa.numStates} states, ${numTransitionEntries} transition entries${stateType}`,
        cells: h.cells,
      });
    }
  }
}